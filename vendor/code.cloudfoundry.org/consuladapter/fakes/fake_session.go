// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"code.cloudfoundry.org/consuladapter"
	"github.com/hashicorp/consul/api"
)

type FakeSession struct {
	CreateStub        func(se *api.SessionEntry, q *api.WriteOptions) (string, *api.WriteMeta, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		se *api.SessionEntry
		q  *api.WriteOptions
	}
	createReturns struct {
		result1 string
		result2 *api.WriteMeta
		result3 error
	}
	CreateNoChecksStub        func(se *api.SessionEntry, q *api.WriteOptions) (string, *api.WriteMeta, error)
	createNoChecksMutex       sync.RWMutex
	createNoChecksArgsForCall []struct {
		se *api.SessionEntry
		q  *api.WriteOptions
	}
	createNoChecksReturns struct {
		result1 string
		result2 *api.WriteMeta
		result3 error
	}
	DestroyStub        func(id string, q *api.WriteOptions) (*api.WriteMeta, error)
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
		id string
		q  *api.WriteOptions
	}
	destroyReturns struct {
		result1 *api.WriteMeta
		result2 error
	}
	InfoStub        func(id string, q *api.QueryOptions) (*api.SessionEntry, *api.QueryMeta, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		id string
		q  *api.QueryOptions
	}
	infoReturns struct {
		result1 *api.SessionEntry
		result2 *api.QueryMeta
		result3 error
	}
	ListStub        func(q *api.QueryOptions) ([]*api.SessionEntry, *api.QueryMeta, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		q *api.QueryOptions
	}
	listReturns struct {
		result1 []*api.SessionEntry
		result2 *api.QueryMeta
		result3 error
	}
	NodeStub        func(node string, q *api.QueryOptions) ([]*api.SessionEntry, *api.QueryMeta, error)
	nodeMutex       sync.RWMutex
	nodeArgsForCall []struct {
		node string
		q    *api.QueryOptions
	}
	nodeReturns struct {
		result1 []*api.SessionEntry
		result2 *api.QueryMeta
		result3 error
	}
	RenewStub        func(id string, q *api.WriteOptions) (*api.SessionEntry, *api.WriteMeta, error)
	renewMutex       sync.RWMutex
	renewArgsForCall []struct {
		id string
		q  *api.WriteOptions
	}
	renewReturns struct {
		result1 *api.SessionEntry
		result2 *api.WriteMeta
		result3 error
	}
	RenewPeriodicStub        func(initialTTL string, id string, q *api.WriteOptions, doneCh chan struct{}) error
	renewPeriodicMutex       sync.RWMutex
	renewPeriodicArgsForCall []struct {
		initialTTL string
		id         string
		q          *api.WriteOptions
		doneCh     chan struct{}
	}
	renewPeriodicReturns struct {
		result1 error
	}
}

func (fake *FakeSession) Create(se *api.SessionEntry, q *api.WriteOptions) (string, *api.WriteMeta, error) {
	fake.createMutex.Lock()
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		se *api.SessionEntry
		q  *api.WriteOptions
	}{se, q})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(se, q)
	} else {
		return fake.createReturns.result1, fake.createReturns.result2, fake.createReturns.result3
	}
}

func (fake *FakeSession) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeSession) CreateArgsForCall(i int) (*api.SessionEntry, *api.WriteOptions) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].se, fake.createArgsForCall[i].q
}

func (fake *FakeSession) CreateReturns(result1 string, result2 *api.WriteMeta, result3 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 string
		result2 *api.WriteMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSession) CreateNoChecks(se *api.SessionEntry, q *api.WriteOptions) (string, *api.WriteMeta, error) {
	fake.createNoChecksMutex.Lock()
	fake.createNoChecksArgsForCall = append(fake.createNoChecksArgsForCall, struct {
		se *api.SessionEntry
		q  *api.WriteOptions
	}{se, q})
	fake.createNoChecksMutex.Unlock()
	if fake.CreateNoChecksStub != nil {
		return fake.CreateNoChecksStub(se, q)
	} else {
		return fake.createNoChecksReturns.result1, fake.createNoChecksReturns.result2, fake.createNoChecksReturns.result3
	}
}

func (fake *FakeSession) CreateNoChecksCallCount() int {
	fake.createNoChecksMutex.RLock()
	defer fake.createNoChecksMutex.RUnlock()
	return len(fake.createNoChecksArgsForCall)
}

func (fake *FakeSession) CreateNoChecksArgsForCall(i int) (*api.SessionEntry, *api.WriteOptions) {
	fake.createNoChecksMutex.RLock()
	defer fake.createNoChecksMutex.RUnlock()
	return fake.createNoChecksArgsForCall[i].se, fake.createNoChecksArgsForCall[i].q
}

func (fake *FakeSession) CreateNoChecksReturns(result1 string, result2 *api.WriteMeta, result3 error) {
	fake.CreateNoChecksStub = nil
	fake.createNoChecksReturns = struct {
		result1 string
		result2 *api.WriteMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSession) Destroy(id string, q *api.WriteOptions) (*api.WriteMeta, error) {
	fake.destroyMutex.Lock()
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
		id string
		q  *api.WriteOptions
	}{id, q})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub(id, q)
	} else {
		return fake.destroyReturns.result1, fake.destroyReturns.result2
	}
}

func (fake *FakeSession) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeSession) DestroyArgsForCall(i int) (string, *api.WriteOptions) {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return fake.destroyArgsForCall[i].id, fake.destroyArgsForCall[i].q
}

func (fake *FakeSession) DestroyReturns(result1 *api.WriteMeta, result2 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 *api.WriteMeta
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) Info(id string, q *api.QueryOptions) (*api.SessionEntry, *api.QueryMeta, error) {
	fake.infoMutex.Lock()
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		id string
		q  *api.QueryOptions
	}{id, q})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub(id, q)
	} else {
		return fake.infoReturns.result1, fake.infoReturns.result2, fake.infoReturns.result3
	}
}

func (fake *FakeSession) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeSession) InfoArgsForCall(i int) (string, *api.QueryOptions) {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return fake.infoArgsForCall[i].id, fake.infoArgsForCall[i].q
}

func (fake *FakeSession) InfoReturns(result1 *api.SessionEntry, result2 *api.QueryMeta, result3 error) {
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 *api.SessionEntry
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSession) List(q *api.QueryOptions) ([]*api.SessionEntry, *api.QueryMeta, error) {
	fake.listMutex.Lock()
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		q *api.QueryOptions
	}{q})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(q)
	} else {
		return fake.listReturns.result1, fake.listReturns.result2, fake.listReturns.result3
	}
}

func (fake *FakeSession) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeSession) ListArgsForCall(i int) *api.QueryOptions {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return fake.listArgsForCall[i].q
}

func (fake *FakeSession) ListReturns(result1 []*api.SessionEntry, result2 *api.QueryMeta, result3 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []*api.SessionEntry
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSession) Node(node string, q *api.QueryOptions) ([]*api.SessionEntry, *api.QueryMeta, error) {
	fake.nodeMutex.Lock()
	fake.nodeArgsForCall = append(fake.nodeArgsForCall, struct {
		node string
		q    *api.QueryOptions
	}{node, q})
	fake.nodeMutex.Unlock()
	if fake.NodeStub != nil {
		return fake.NodeStub(node, q)
	} else {
		return fake.nodeReturns.result1, fake.nodeReturns.result2, fake.nodeReturns.result3
	}
}

func (fake *FakeSession) NodeCallCount() int {
	fake.nodeMutex.RLock()
	defer fake.nodeMutex.RUnlock()
	return len(fake.nodeArgsForCall)
}

func (fake *FakeSession) NodeArgsForCall(i int) (string, *api.QueryOptions) {
	fake.nodeMutex.RLock()
	defer fake.nodeMutex.RUnlock()
	return fake.nodeArgsForCall[i].node, fake.nodeArgsForCall[i].q
}

func (fake *FakeSession) NodeReturns(result1 []*api.SessionEntry, result2 *api.QueryMeta, result3 error) {
	fake.NodeStub = nil
	fake.nodeReturns = struct {
		result1 []*api.SessionEntry
		result2 *api.QueryMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSession) Renew(id string, q *api.WriteOptions) (*api.SessionEntry, *api.WriteMeta, error) {
	fake.renewMutex.Lock()
	fake.renewArgsForCall = append(fake.renewArgsForCall, struct {
		id string
		q  *api.WriteOptions
	}{id, q})
	fake.renewMutex.Unlock()
	if fake.RenewStub != nil {
		return fake.RenewStub(id, q)
	} else {
		return fake.renewReturns.result1, fake.renewReturns.result2, fake.renewReturns.result3
	}
}

func (fake *FakeSession) RenewCallCount() int {
	fake.renewMutex.RLock()
	defer fake.renewMutex.RUnlock()
	return len(fake.renewArgsForCall)
}

func (fake *FakeSession) RenewArgsForCall(i int) (string, *api.WriteOptions) {
	fake.renewMutex.RLock()
	defer fake.renewMutex.RUnlock()
	return fake.renewArgsForCall[i].id, fake.renewArgsForCall[i].q
}

func (fake *FakeSession) RenewReturns(result1 *api.SessionEntry, result2 *api.WriteMeta, result3 error) {
	fake.RenewStub = nil
	fake.renewReturns = struct {
		result1 *api.SessionEntry
		result2 *api.WriteMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSession) RenewPeriodic(initialTTL string, id string, q *api.WriteOptions, doneCh chan struct{}) error {
	fake.renewPeriodicMutex.Lock()
	fake.renewPeriodicArgsForCall = append(fake.renewPeriodicArgsForCall, struct {
		initialTTL string
		id         string
		q          *api.WriteOptions
		doneCh     chan struct{}
	}{initialTTL, id, q, doneCh})
	fake.renewPeriodicMutex.Unlock()
	if fake.RenewPeriodicStub != nil {
		return fake.RenewPeriodicStub(initialTTL, id, q, doneCh)
	} else {
		return fake.renewPeriodicReturns.result1
	}
}

func (fake *FakeSession) RenewPeriodicCallCount() int {
	fake.renewPeriodicMutex.RLock()
	defer fake.renewPeriodicMutex.RUnlock()
	return len(fake.renewPeriodicArgsForCall)
}

func (fake *FakeSession) RenewPeriodicArgsForCall(i int) (string, string, *api.WriteOptions, chan struct{}) {
	fake.renewPeriodicMutex.RLock()
	defer fake.renewPeriodicMutex.RUnlock()
	return fake.renewPeriodicArgsForCall[i].initialTTL, fake.renewPeriodicArgsForCall[i].id, fake.renewPeriodicArgsForCall[i].q, fake.renewPeriodicArgsForCall[i].doneCh
}

func (fake *FakeSession) RenewPeriodicReturns(result1 error) {
	fake.RenewPeriodicStub = nil
	fake.renewPeriodicReturns = struct {
		result1 error
	}{result1}
}

var _ consuladapter.Session = new(FakeSession)
